package xyz.rrtt217.core;

import ar.com.hjg.pngj.ImageInfo;
import ar.com.hjg.pngj.ImageLineInt;
import ar.com.hjg.pngj.IImageLine;
import ar.com.hjg.pngj.PngWriter;
import ar.com.hjg.pngj.chunks.PngChunkICCP;
import com.mojang.blaze3d.buffers.GpuBuffer;
import com.mojang.blaze3d.pipeline.RenderTarget;
import com.mojang.blaze3d.systems.CommandEncoder;
import com.mojang.blaze3d.systems.RenderSystem;
import com.mojang.blaze3d.textures.GpuTexture;
import me.shedaniel.autoconfig.AutoConfig;
import net.minecraft.ChatFormatting;
import net.minecraft.client.Minecraft;
import net.minecraft.network.chat.ClickEvent;
import net.minecraft.network.chat.Component;
import net.minecraft.util.Util;
import org.jspecify.annotations.Nullable;
import xyz.rrtt217.HDRMod;
import xyz.rrtt217.config.HDRModConfig;
import xyz.rrtt217.util.Enums;
import xyz.rrtt217.util.GLFWColorManagement;
import xyz.rrtt217.util.HDRModInjectHooks;
import xyz.rrtt217.util.LibraryExtractor;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.function.Consumer;

public class PngjHDRScreenshot {
    public static final String SCREENSHOT_DIR = "screenshots";
    public static void grab(File baseDirectory, RenderTarget renderTarget, Consumer<Component> consumer) {
        grab(baseDirectory, (String)null, renderTarget, consumer);
    }
    public static void grab(File baseDirectory, @Nullable String string, RenderTarget renderTarget, Consumer<Component> consumer) {
        // Mod config.
        HDRModConfig config = AutoConfig.getConfigHolder(HDRModConfig.class).getConfig();

        // Width and height.
        int width = renderTarget.width;
        int height = renderTarget.height;

        // Pngj things.
        ImageInfo imi = new ImageInfo(width, height, 16, false);
        File screenshotFile = getScreenshotFile(new File(baseDirectory,SCREENSHOT_DIR));
        PngWriter png = new PngWriter(screenshotFile, imi);
        png.getMetadata().setDpi(100.0);
        png.getMetadata().setTimeNow(0);
        PngChunkICCP chunkICCP = new PngChunkICCP(imi);

        // Extracted iCCP that is supposed to generated by libjxl
        try(InputStream is = LibraryExtractor.class.getClassLoader().getResourceAsStream("iccs/RGB_D65_202_Rel_PeQ.icc")){
            if(is == null) {
                throw new FileNotFoundException("Could not find icc file: " + string);
            }
            chunkICCP.setProfileNameAndContent("RGB_D65_202_Rel_PeQ",is.readAllBytes());
            png.queueChunk(chunkICCP);
        }
        catch (Exception e) {
            HDRMod.LOGGER.error("Error while trying to grab screenshot for {}", string, e);
            return;
        }

        // The actual screenshot part (why it's so slow?)
        GpuTexture gpuTexture = renderTarget.getColorTexture();
        if (gpuTexture == null) {
            throw new IllegalStateException("Tried to capture screenshot of an incomplete framebuffer");
        }
        else{
            // Get the buffer.
            GpuBuffer gpuBuffer = RenderSystem.getDevice().createBuffer(() -> "HDR Mod Screenshot buffer", 9, (long) width * (long) height * 8L);
            CommandEncoder commandEncoder = RenderSystem.getDevice().createCommandEncoder();
            // Enable readPixel inject.
            HDRModInjectHooks.enableInject();
            RenderSystem.getDevice().createCommandEncoder().copyTextureToBuffer(gpuTexture, gpuBuffer, 0L, () -> {
                try (GpuBuffer.MappedView mappedView = commandEncoder.mapBuffer(gpuBuffer, true, false)) {
                    // Don't get upsided down lol
                    for (int y = height - 1; y >= 0; y--) {
                        // Line by line.
                        ImageLineInt line = new ImageLineInt(imi);
                        int[] scanline = line.getScanline();
                        for (int x = 0; x < width; x++) {
                            // Interpret data.
                            float[] datas = new float[4];
                            int basePos = ((y * width + x) * 4) * 2;
                            for (int c = 0; c < 4; c++) {
                                short bits = mappedView.data().getShort(basePos + c * 2);
                                datas[c] = Float.float16ToFloat(bits);
                            }
                            // Do transform.
                            if (HDRMod.WindowPrimaries == Enums.Primaries.SRGB) {
                                float[] rgb = Arrays.copyOf(datas, 3);
                                System.arraycopy(linearColorspaceTransform(rgb, linear709to2020Matrix), 0, datas, 0, 3);
                            }
                            if (HDRMod.WindowTransferFunction == Enums.TransferFunction.EXT_LINEAR) {
                                float[] rgb = Arrays.copyOf(datas, 3);
                                System.arraycopy(scRGBtoPQ(rgb, config.autoSetGamePaperWhiteBrightness ? GLFWColorManagement.glfwGetWindowSdrWhiteLevel(Minecraft.getInstance().getWindow().handle()) : config.customGamePaperWhiteBrightness), 0, datas, 0, 3);
                            }
                            // Write to line.
                            for (int c = 0; c < png.imgInfo.channels; c++) {
                                scanline[x * png.imgInfo.channels + c] = (int) (datas[c] * 65535);
                            }
                        }
                        // Write to file.
                        png.writeRow(line);
                    }
                    // Close the file.
                    png.end();
                } catch (Exception e) {
                    HDRMod.LOGGER.error("Error while trying to capture screenshot for {}", string, e);
                }
                // Close the buffer.
                gpuBuffer.close();
            }, 0);
            // Disable injection.
            HDRModInjectHooks.disableInject();
            Component component = Component.literal(screenshotFile.getName()).withStyle(ChatFormatting.UNDERLINE).withStyle((style) -> style.withClickEvent(new ClickEvent.OpenFile(screenshotFile.getAbsoluteFile())));
            consumer.accept(Component.translatable("screenshot.success", new Object[]{component}));
        }
        }
    private static File getScreenshotFile(File baseDirectory) {
        String string = Util.getFilenameFormattedDateTime();
        int i = 1;
        while(true) {
            File screenshotFile = new File(baseDirectory, string + (i == 1 ? "" : "_" + i) + "_hdr" + ".png");
            if (!screenshotFile.exists()) {
                return screenshotFile;
            }
            ++i;
        }
    }


    // Will move the following methods to a seperate class.
    public static float readHalfFloat(byte[] data, int offset, boolean littleEndian) {
        short bits = (short) (((data[offset + 1] & 0xFF) << 8) | (data[offset] & 0xFF));
        if (!littleEndian) {
            bits = (short) (((data[offset] & 0xFF) << 8) | (data[offset + 1] & 0xFF));
        }
        return Float.float16ToFloat(bits);
    }

    public static float[] scRGBtoPQ(float[] scRGB, float referenceWhiteNits) {
        // PQ constants (SMPTE ST 2084)
        final float m1 = 2610.0f / 16384.0f;        // 0.1593017578125
        final float m2 = 2523.0f / 4096.0f;         // 0.615234375
        final float c1 = 3424.0f / 4096.0f;         // 0.8359375
        final float c2 = 2413.0f / 4096.0f * 32.0f; // 18.8515625
        final float c3 = 2392.0f / 4096.0f * 32.0f; // 18.6875

        float[] pq = new float[3];
        for (int i = 0; i < 3; i++) {
            // scRGB to absolute brightness
            float linearNits = scRGB[i] * referenceWhiteNits;

            // Clamp
            linearNits = Math.max(linearNits, 0.0f);

            // Normalise
            float Y = linearNits / 10000.0f;
            Y = Math.min(Y, 1.0f); // 规范要求 Y ≤ 1

            // PQ encode
            float Ypow = (float) Math.pow(Y, m1);
            float num = c1 + c2 * Ypow;
            float den = 1.0f + c3 * Ypow;
            float V = (float) Math.pow(num / den, m2);

            pq[i] = V;
        }
        return pq;
    }

    public static float[] linearColorspaceTransform(float[] originalData, float[][] transformMatrix){
        float r = originalData[0];
        float g = originalData[1];
        float b = originalData[2];

        float rnew = transformMatrix[0][0] * r + transformMatrix[0][1] * g + transformMatrix[0][2] * b;
        float gnew = transformMatrix[1][0] * r + transformMatrix[1][1] * g + transformMatrix[1][2] * b;
        float bnew = transformMatrix[2][0] * r + transformMatrix[2][1] * g + transformMatrix[2][2] * b;

        return new float[]{rnew, gnew, bnew};
    }
    public static final float[][] linear709to2020Matrix =  new float[][]{
        {0.6274039149284363f, 0.3292830288410187f, 0.04331306740641594f},
        {0.06909728795289993f, 0.9195404052734375f, 0.01136231515556574f},
        {0.0163914393633604f, 0.08801330626010895f, 0.8955952525138855f}
    };
}

